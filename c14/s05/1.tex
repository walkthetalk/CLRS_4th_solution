\startEXERCISE
設計僞碼 \ALGO{CONSTRUCT-OPTIMAL-BST(root)}，
輸入爲表 $root[1:n,1:n]$，
輸出是最優二叉搜索樹的結構。
例如圖 14.10，應輸出：

$k_2$ 爲根

$k_1$ 爲 $k_2$ 的左孩子

$d_0$ 爲 $k_1$ 的左孩子

$d_1$ 爲 $k_1$ 的右孩子

$k_5$ 爲 $k_2$ 的右孩子

$k_4$ 爲 $k_5$ 的左孩子

$k_3$ 爲 $k_4$ 的左孩子

$d_2$ 爲 $k_3$ 的左孩子

$d_3$ 爲 $k_3$ 的右孩子

$d_4$ 爲 $k_4$ 的右孩子

$d_5$ 爲 $k_5$ 的右孩子

與圖 14.9(b) 中的最優二叉搜索樹對應。
\stopEXERCISE

\startANSWER
\CLRSH{CONSTRUCT-OPTIMAL-BST(root)}
\startCLRSCODE
\ALGO{PRINT}(\text{"\{\}是根"}, root[1, n])
p<-0
\ALGO{PRINT-OPTIMAL-BST(root, 1, n)}
\stopCLRSCODE

\CLRSH{PRINT-OPTIMAL-BST(root, i, j)}
\startCLRSCODE
if root[i, root[i, j]-1]
	\ALGO{PRINT}(\text{"\{\}是\{\}的左孩子"}, root[i, root[i, j]-1], root[i, j])
	\ALGO{PRINT-OPTIMAL-BST(root, i, root[i, j]-1)}

if root[root[i, j]+1, j]
	\ALGO{PRINT}(\text{"\{\}是\{\}的右孩子"}, root[root[i, j]+1, j], root[i, j])
	\ALGO{PRINT-OPTIMAL-BST(root, root[i, j]+1, j)}
\stopCLRSCODE
\stopANSWER
