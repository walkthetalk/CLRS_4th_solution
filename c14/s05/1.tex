\startEXERCISE
設計僞碼 \ALGO{CONSTRUCT-OPTIMAL-BST(root)}，
輸入爲表 $root[1:n,1:n]$，
輸出是最優二叉搜索樹的結構。
例如圖 14.10，應輸出：

\startigBase
\item $k_2$ 爲根
\item $k_1$ 爲 $k_2$ 的左孩子
\item $d_0$ 爲 $k_1$ 的左孩子
\item $d_1$ 爲 $k_1$ 的右孩子
\item $k_5$ 爲 $k_2$ 的右孩子
\item $k_4$ 爲 $k_5$ 的左孩子
\item $k_3$ 爲 $k_4$ 的左孩子
\item $d_2$ 爲 $k_3$ 的左孩子
\item $d_3$ 爲 $k_3$ 的右孩子
\item $d_4$ 爲 $k_4$ 的右孩子
\item $d_5$ 爲 $k_5$ 的右孩子
\stopigBase
與圖 14.9(b) 中的最優二叉搜索樹對應。
\stopEXERCISE

\startANSWER
\CLRSH{CONSTRUCT-OPTIMAL-BST(root)}
\startCLRSCODE
print "k" root[1, n] "是根"
p<-0
PRINT-OPTIMAL-BST(root, 1, n)
\stopCLRSCODE

\CLRSH{PRINT-OPTIMAL-BST(root, i, j)}
\startCLRSCODE
if root[i, root[i, j]-1]
	print "k" root[i, root[i, j]-1] "是k" root[i, j] "的左孩子"
	PRINT-OPTIMAL-BST(root, i, root[i, j]-1)
else
	print "d" p "是k" root[i, j] "的左孩子"
	p<-p+1
if root[root[i, j]+1, j]
	print "k" root[root[i, j]+1, j] "是k" root[i, j] "的右孩子"
	PRINT-OPTIMAL-BST(root, root[i, j]+1, j)
else
	print "d" p "是k" root[i, j] "的右孩子"
	p<-p+1
\stopCLRSCODE
\stopANSWER
